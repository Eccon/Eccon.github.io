<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>使用 Nginx 搭建 RouterOS 升级服务器镜像，加速 ROS 在线升级</title>
    <url>/post/55092.html</url>
    <content><![CDATA[<!-- build time:Wed Feb 26 2020 12:44:53 GMT+0800 (China Standard Time) --><p>昨日家里网络故障，进排查发现是入户光纤损坏导致，今天师傅上门解决好后，登录主路由（RouterOS）检查拨号状态，发现有新版本可以升级，于是点击升级，可是由于某种不可描述的原因，升级下载缓慢，升级中断等等网络问题，于是使用 Nginx 反代了官方下载地址，升级体验嗖嗖的提升,冲冲冲！</p><a id="more"></a><hr><h1 id="修改-DNS-记录"><a href="#修改-DNS-记录" class="headerlink" title="修改 DNS 记录"></a>修改 DNS 记录</h1><ul><li>登录 ROS 管理页面，依次打开<code>IP-DNS-Static-Add New</code>,Name 填写<code>upgrade.mikrotik.com</code>,Address 填写服务器 IP，比如我的服务器 IP 是 1.1.1.1,这里的 Name 是升级服务器域名，Address 是我们自己的服务器，用来反代。</li></ul><p><img data-src="https://cdn.jsdelivr.net/gh/Eccon/image@master/hexo_blog_img/2020-2-23-17-40-49.png" alt="增加 DNS 记录.png"></p><ul><li>这时候打开<code>System-Packages-Check_For_Updates</code>,点击更新会提示 ERROR: connection timed out,这是因为我们还没有配置服务端，只是完成了本地的工作</li></ul><p><img data-src="https://cdn.jsdelivr.net/gh/Eccon/image@master/hexo_blog_img/2020-2-23-17-43-35.png" alt="ERROR: connection timed out"></p><h1 id="配置服务端"><a href="#配置服务端" class="headerlink" title="配置服务端"></a>配置服务端</h1><ul><li>新增一个 Nginx 配置文件，<code>upgrade.mikrotik.com.conf</code>,配置如下：</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name upgrade.mikrotik.com;</span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line"></span><br><span class="line">        proxy_redirect off;</span><br><span class="line">        proxy_pass http:&#x2F;&#x2F;upgrade.mikrotik.com&#x2F;;</span><br><span class="line">        proxy_http_version 1.1;</span><br><span class="line">        proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">        proxy_set_header Upgrade $http_upgrade;</span><br><span class="line">        proxy_set_header Connection &quot;upgrade&quot;;</span><br><span class="line">        proxy_set_header Host upgrade.mikrotik.com;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>保存文件，执行<code>nginx -s reload</code>.</p><p>至此，搭建完毕，就可以正常使用了。</p><p>简单说一下思路，由于官方并未提供自定义升级地址的选项，也就是说，默认的升级域名<code>upgrade.mikrotik.com</code>我们是没有办法修改的，按照常规的反代思路是行不通的，所以我们要将路由器的 DNS 解析劫持到我们自己的服务器，服务器收到请求后，判断 server_name，反代官方下载地址，这样就可以实现另类反代镜像搭建了，同样适用于其他需要镜像加速且没办法修改默认域名的情况。</p><hr><h1 id="验证效果"><a href="#验证效果" class="headerlink" title="验证效果"></a>验证效果</h1><ul><li>再次点击更新，页面会显示 New version is available.证明我们这个服务搭建成功了。</li></ul><p><img data-src="https://cdn.jsdelivr.net/gh/Eccon/image@master/hexo_blog_img/2020-2-23-17-52-6.png" alt="New version is available"></p><ul><li>然后点击 Download，下载速度嗖嗖提升，我们在服务端查看 Nginx 的 log，也可以看到请求日志，证明下载确实走了搭建的镜像服务器而不是官方默认服务器。</li></ul><p><img data-src="https://cdn.jsdelivr.net/gh/Eccon/image@master/hexo_blog_img/2020-2-23-17-54-47.png" alt="Nginx-log"></p><p>Over~</p><!-- rebuild by neat -->]]></content>
  </entry>
  <entry>
    <title>使用 Travis CI 自动部署 Hexo</title>
    <url>/post/48120.html</url>
    <content><![CDATA[<!-- build time:Wed Feb 26 2020 12:44:53 GMT+0800 (China Standard Time) --><p>记录一下使用 Travis 这类 CI/CD 工具进行 Hexo 的自动部署，同类的持续集成工具还有 Jenkins、circleci 以及 Github 官方推出的 Github Actions。</p><a id="more"></a><h2 id="持续集成"><a href="#持续集成" class="headerlink" title="持续集成"></a>持续集成</h2><p>持续集成服务（Continuous Integration，简称 CI）。简单的说，持续集成就像工厂的全自动流水线一样，当你项目中的代码有变动，就会触发持续集成作业，根据配置文件提供对应的运行环境，执行测试，完成构建，甚至部署到服务器。</p><hr><h2 id="自动部署的优点"><a href="#自动部署的优点" class="headerlink" title="自动部署的优点"></a>自动部署的优点</h2><ol><li><p>一处提交，到处部署: 以部署 Hexo 为例，如果想同时部署到 Github pages、Coding pags 等，传统手动的方式是要拷贝多份项目，分别配置不同的远程仓库，每次新增文件，修改配置都要在多个副本中进行同步，部署的时候需要多次部署，非常非常不方便，而有了持续集成工具以后，我们就可以做到，一处提交，到处部署，极大的简化了部署流程。</p></li><li><p>更加方便：传统的方式，我们需要在本地装 Node.js 环境，还要装 Hexo等；有了持续集成，无需在本地安装编译环境，只需要负责项目的代码或者负责文章的内容，剩下的工作交给 Travis 即可，要多省心就有多省心。</p></li><li><p>还是方便：比如你现在临时想要修改某篇文章、修改某行代码，甚至不用将项目拉到本地，直接用浏览器编辑文件然后保存，即可触发自动化作业；对于写博客来说，只要你愿意，用浏览器写文章也不是不可以。</p></li><li><p>想到再补充…</p></li></ol><hr><h2 id="配置步骤"><a href="#配置步骤" class="headerlink" title="配置步骤"></a>配置步骤</h2><h3 id="1-登录Travis-CI的网站：https-travis-ci-com"><a href="#1-登录Travis-CI的网站：https-travis-ci-com" class="headerlink" title="1. 登录Travis CI的网站：https://travis-ci.com/"></a>1. 登录Travis CI的网站：<span class="exturl" data-url="aHR0cHM6Ly90cmF2aXMtY2kuY29tLw==" title="https://travis-ci.com/">https://travis-ci.com/<i class="fa fa-external-link"></i></span></h3><p>初次接触，你会发现有 <span class="exturl" data-url="aHR0cHM6Ly90cmF2aXMtY2kuY29tLw==" title="https://travis-ci.com/">https://travis-ci.com/<i class="fa fa-external-link"></i></span> 和 <span class="exturl" data-url="aHR0cHM6Ly90cmF2aXMtY2kub3JnLw==" title="https://travis-ci.org/">https://travis-ci.org/<i class="fa fa-external-link"></i></span> 两个网站，按照网上的说法就是，org 结尾的网站面向开源项目（这里定义为 Github 上公开仓库都算做开源项目）免费使用；而 com 结尾的网站面向企业等（Github 上面的私有仓库）提供收费服务。</p><p>但是，我又发现了下面这个<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLnRyYXZpcy1jaS5jb20vMjAxOC0wNS0wMi1vcGVuLXNvdXJjZS1wcm9qZWN0cy1vbi10cmF2aXMtY2ktY29tLXdpdGgtZ2l0aHViLWFwcHM=" title="https://blog.travis-ci.com/2018-05-02-open-source-projects-on-travis-ci-com-with-github-apps">官方说明<i class="fa fa-external-link"></i></span>，里面的大致内容是说,从2018年5月起，公开仓库和私有仓库都可以使用 <span class="exturl" data-url="aHR0cHM6Ly90cmF2aXMtY2kuY29tLw==" title="https://travis-ci.com/">https://travis-ci.com/<i class="fa fa-external-link"></i></span> 进行部署，换言之，org 逐渐迁移到 com，以后统一使用 <span class="exturl" data-url="aHR0cHM6Ly90cmF2aXMtY2kuY29tLw==" title="https://travis-ci.com/">https://travis-ci.com/<i class="fa fa-external-link"></i></span></p><p>打开 <span class="exturl" data-url="aHR0cHM6Ly90cmF2aXMtY2kuY29tLw==" title="https://travis-ci.com/">https://travis-ci.com/<i class="fa fa-external-link"></i></span> ， 点击右上角 <code>Sign in with GitHub</code> 使用 Github 账号进行登录，登录后，页面是这个样子的。 <img data-src="https://cdn.jsdelivr.net/gh/Eccon/image@master/hexo_blog_img/20191201150932.png" alt="登录后"></p><p>点击右上角的头像，点 <code>Setting</code> ，进来后就是下面这个鸟样。<img data-src="https://cdn.jsdelivr.net/gh/Eccon/image@master/hexo_blog_img/20191201151223.png" alt=""><br>点击 <code>Activate</code><br><img data-src="https://cdn.jsdelivr.net/gh/Eccon/image@master/hexo_blog_img/20191201151405.png" alt=""><br>这里选择我们要绑定的项目仓库，也可以直接绑定所有仓库，后面还可以在 Github 设置里面随时修改，然后点击 <code>Approve &amp; Install</code> ，到这里，就完成了绑定操作</p><h3 id="2-travis-yml-配置文件"><a href="#2-travis-yml-配置文件" class="headerlink" title="2. .travis.yml 配置文件"></a>2. .travis.yml 配置文件</h3><p>之所以 Travis 能够自动触发任务，就是因为这个配置文件的存在，在项目根目录新建 <code>.travis.yml</code> 配置文件，Travis 就会读取里面的内容，进行监听，进而实现自动化。</p><p>关于配置文件的详细介绍，可以去 Travis 官方文档阅读学习一下，下面贴出本次部署用的配置文件。</p><p>贴出之前，简单交代一下背景，博客源文件和部署都在同一个项目上，其中，源代码在分支 <code>hexo</code> 上面，而 <code>master</code> 分支用来存放部署文件，也就是你现在所看到的页面的相关文件。</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 配置编译语言以及需要的版本</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">node_js</span></span><br><span class="line"><span class="attr">node_js:</span> <span class="string">stable</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置监听的分支，这里配置 hexo 分支，也就是监听源文件的改动</span></span><br><span class="line"><span class="attr">branches:</span></span><br><span class="line">  <span class="attr">only:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">hexo</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置缓存，加快部署时间</span></span><br><span class="line"><span class="comment">#cache</span></span><br><span class="line"><span class="attr">cache:</span></span><br><span class="line">  <span class="attr">apt:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">directories:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">"node_modules"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="attr">before_install:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">export</span> <span class="string">TZ='Asia/Shanghai'</span> <span class="comment"># 更改时区，不然默认提交时间是 UTC 标准时间</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">npm</span> <span class="string">install</span> <span class="string">-g</span> <span class="string">hexo-cli</span>  <span class="comment"># 部署环境安装 hexo</span></span><br><span class="line"></span><br><span class="line"><span class="attr">install:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">npm</span> <span class="string">install</span>  <span class="comment"># 安装依赖</span></span><br><span class="line"></span><br><span class="line"><span class="attr">script:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">hexo</span> <span class="string">clean</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">hexo</span> <span class="string">generate</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 部署方式一,这里是 hexo 官方文档给出的部署方式</span></span><br><span class="line"><span class="comment"># deploy:</span></span><br><span class="line"><span class="comment">#   provider: pages</span></span><br><span class="line"><span class="comment">#   skip_cleanup: true</span></span><br><span class="line"><span class="comment">#   github_token: $ACCESS_TOKEN  #访问 token，该变量在 Travis 中设置，下面会介绍</span></span><br><span class="line"><span class="comment">#   keep_history: true</span></span><br><span class="line"><span class="comment">#   on:</span></span><br><span class="line"><span class="comment">#     branch: hexo </span></span><br><span class="line"><span class="comment">#   email: youremail  #设置 commit 的邮箱</span></span><br><span class="line"><span class="comment">#   name: yourname   #设置 commit 的用户名</span></span><br><span class="line"><span class="comment">#   target_branch: master  # 设置部署的目标分支</span></span><br><span class="line"><span class="comment">#   local-dir: public  #将 public 中的内容部署到 master 分支，如果没有此项配置，会把所有的源文件部署到 master 分支，而不是 hexo g 后生成的静态文件。（hexo g 后的静态页面文件存放在 public 目录下）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 部署方式二，网上大多数人采用的是这种方式部署</span></span><br><span class="line"><span class="attr">after_script:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">git</span> <span class="string">clone</span> <span class="string">$&#123;GH_REF_SSH&#125;</span> <span class="string">.deploy_git</span> <span class="comment">#先拉取项目，取得历史提交记录</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">cd</span> <span class="string">.deploy_git</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">git</span> <span class="string">checkout</span> <span class="string">master</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">cd</span> <span class="string">../</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">mv</span> <span class="string">.deploy_git/.git/</span> <span class="string">./public/</span>  <span class="comment">## 拷贝历史 commit 记录，不然每次构建都是全新的环境，造成历史 commit 记录被清空</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">cd</span> <span class="string">./public</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">git</span> <span class="string">config</span> <span class="string">user.name</span> <span class="string">"yourname"</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">git</span> <span class="string">config</span> <span class="string">user.email</span> <span class="string">"youremail"</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">git</span> <span class="string">add</span> <span class="string">.</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">git</span> <span class="string">commit</span> <span class="string">-m</span> <span class="string">"Site updated `date +"</span><span class="string">%Y-%m-%d</span> <span class="string">%H:%M"`.</span> <span class="string">Auto</span> <span class="string">Deploy</span> <span class="string">By</span> <span class="string">TravisCI</span> <span class="string">:)"</span></span><br><span class="line">  <span class="comment"># Github Pages</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">git</span> <span class="string">push</span>  <span class="string">--force</span> <span class="string">--quiet</span> <span class="string">"https://$&#123;ACCESS_TOKEN&#125;@$&#123;GH_REF&#125;"</span> <span class="string">master:master</span> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## 变量</span></span><br><span class="line"><span class="attr">env:</span></span><br><span class="line"> <span class="attr">global:</span></span><br><span class="line">   <span class="bullet">-</span> <span class="attr">GH_REF:</span> <span class="string">github.com/Eccon/Eccon.github.io</span></span><br><span class="line">   <span class="bullet">-</span> <span class="attr">GH_REF_SSH:</span> <span class="string">git@github.com:Eccon/Eccon.github.io.git</span></span><br></pre></td></tr></table></figure><p>上面的配置文件介绍了两种部署方式，可以根据需要进行选择，为了让 Travis 有提交代码的权限，上面的配置文件介绍了两种方式，一种是根据 SSH 进行推送，需要配置私钥；另一种是配置 Token 的方式进行部署</p><ul><li><p>配置私钥：</p><p>打开 Travis 项目的 Setting，往下拉，找到 <code>SSH Key</code> ，将有访问 Github 仓库权限的私钥放到上面，保存即可</p></li><li><p>配置 Token：</p><p>上面的配置文件，用到了一个变量 <code>${ACCESS_TOKEN}</code> ，这个也是在 Travis 里面设置的。首先要去 Github 生成一个 Token，打开 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3NldHRpbmdzL3Rva2Vucw==" title="https://github.com/settings/tokens">https://github.com/settings/tokens<i class="fa fa-external-link"></i></span> ，<img data-src="https://cdn.jsdelivr.net/gh/Eccon/image@master/hexo_blog_img/20191201160227.png" alt=""> 生成的 Token 只会显示一次，复制后，打开 Travis 的 Setting, 找到 <code>Environment Variables</code> ，<code>NAME</code> 填写 <code>ACCESS_TOKEN</code> ,<code>VALUE</code> 填写刚才复制的 Token，不要勾选 <code>DISPLAY VALUE IN BUILD LOG</code>，不然 Token 会暴露在日志中，造成泄露,保存即可<img data-src="https://cdn.jsdelivr.net/gh/Eccon/image@master/hexo_blog_img/20191201160549.png" alt=""></p></li></ul><h3 id="3-触发构建"><a href="#3-触发构建" class="headerlink" title="3. 触发构建"></a>3. 触发构建</h3><p>我们将配置文件保存，然后 <code>git add . &amp;&amp; git commit -m &quot;&quot; &amp;&amp; git push</code> 一系列操作，将项目的改动推到 Github 远程操作，这时候打开 Travis，就可以看到构建日志了<br><img data-src="https://cdn.jsdelivr.net/gh/Eccon/image@master/hexo_blog_img/20191201161259.png" alt=""><br>等待构建完成即可,还可以查看构建历史记录<br><img data-src="https://cdn.jsdelivr.net/gh/Eccon/image@master/hexo_blog_img/20191201161527.png" alt=""><br>然后我们打开 Github 仓库主页，看一下提交记录<br><img data-src="https://cdn.jsdelivr.net/gh/Eccon/image@master/hexo_blog_img/20191201161709.png" alt=""><br>整个过程下来，体验极其愉快，以后只需要把文章更新上去，剩下的全自动部署发布，超级方便，这里以部署 Hexo 为例简单介绍了 CI 的实际应用场景之一，对于 CI 工具而言，实际功能远不止于此。</p><hr><h2 id="已知问题"><a href="#已知问题" class="headerlink" title="已知问题"></a>已知问题</h2><ol><li><p>使用第一种部署方式，commit 的信息无法自定义，晚上也没有找到自定义的方式，暂无解决方案</p></li><li><p>使用第二种部署方式，根据网上那些配置，会造成历史 commit 记录丢失的问题，也就是你在 Github 仓库上看到的永远只有最后一次提交记录点，解决方法见上面配置文件的第二种配置方式</p></li><li><p>待补充</p></li></ol><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol><li><span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL3poLWNuL2RvY3MvZ2l0aHViLXBhZ2VzI1ByaXZhdGUtcmVwb3NpdG9yeQ==" title="https://hexo.io/zh-cn/docs/github-pages#Private-repository">https://hexo.io/zh-cn/docs/github-pages#Private-repository<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnRyYXZpcy1jaS5jb20vdXNlci9kZXBsb3ltZW50L3BhZ2VzLw==" title="https://docs.travis-ci.com/user/deployment/pages/">https://docs.travis-ci.com/user/deployment/pages/<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9kZXZvcHMuc3RhY2tleGNoYW5nZS5jb20vcXVlc3Rpb25zLzEyMDEvd2hhdHMtdGhlLWRpZmZlcmVuY2UtYmV0d2Vlbi10cmF2aXMtY2ktb3JnLWFuZC10cmF2aXMtY2ktY29t" title="https://devops.stackexchange.com/questions/1201/whats-the-difference-between-travis-ci-org-and-travis-ci-com">https://devops.stackexchange.com/questions/1201/whats-the-difference-between-travis-ci-org-and-travis-ci-com<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cubGlhb3h1ZWZlbmcuY29tL2FydGljbGUvMTA4MzEwMzU2Mjk1NTEzNg==" title="https://www.liaoxuefeng.com/article/1083103562955136">https://www.liaoxuefeng.com/article/1083103562955136<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3N0ZXZla2xhYm5pay9hdXRvbWF0aWNhbGx5X3VwZGF0ZV9naXRodWJfcGFnZXNfd2l0aF90cmF2aXNfZXhhbXBsZQ==" title="https://github.com/steveklabnik/automatically_update_github_pages_with_travis_example">https://github.com/steveklabnik/automatically_update_github_pages_with_travis_example<i class="fa fa-external-link"></i></span></li></ol><h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2><p>Auto Deploy By TravisCI :)</p><!-- rebuild by neat -->]]></content>
  </entry>
  <entry>
    <title>Git 常见问题解决</title>
    <url>/post/6331.html</url>
    <content><![CDATA[<!-- build time:Wed Feb 26 2020 12:44:53 GMT+0800 (China Standard Time) --><p>记录一下在使用 git 的过程中遇到的问题</p><a id="more"></a><h3 id="1-中文没有被转义，显示成-569-586这种格式"><a href="#1-中文没有被转义，显示成-569-586这种格式" class="headerlink" title="1. 中文没有被转义，显示成/569/586这种格式"></a>1. 中文没有被转义，显示成/569/586这种格式</h3><p><code>git config core.quotepath false</code></p><hr><h3 id="2-git-branch-后，进入编辑模式，结尾显示（END）"><a href="#2-git-branch-后，进入编辑模式，结尾显示（END）" class="headerlink" title="2. git branch 后，进入编辑模式，结尾显示（END）"></a>2. git branch 后，进入编辑模式，结尾显示（END）</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config  core.pager &#39;&#39; </span><br><span class="line">或者 </span><br><span class="line">git config  core.pager cat</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
  </entry>
  <entry>
    <title>被关照了</title>
    <url>/post/29930.html</url>
    <content><![CDATA[<!-- build time:Wed Feb 26 2020 12:44:53 GMT+0800 (China Standard Time) --><p>6.1儿童节的惊喜？</p><a id="more"></a><p>昨天晚上大概九点多的时候，突然打不开网页，Telegram 也一直在转圈圈无法刷新消息，但是微信什么的却丝毫不受影响，于是看了一眼梯子，发现和服务器连不上了，这个时候我的感觉就是，“坏了，IP 被墙了”，然后找了一个批量 ping 检测的网站，就是下面这样子了。<br><img data-src="https://cdn.jsdelivr.net/gh/Eccon/image@master/hexo_blog_img/20190602104629.png" alt=""><br>……<br>……<br>……</p><p>这类事情以前经常发生，只不过之前都是看别人发生，每次还很幸灾乐祸的觉得自己逃过一劫，没想到这次…该来的还是来了。</p><hr><p>今天早上起来后，感觉很不在状态，坐了一上午，什么都没有干，可能和昨天 IP 被墙有关系，虽然不是什么大问题（有备用方案，后续还可以换一个新的 IP），但是今天就是莫名的蔫儿，再加上毕业临近，好水逆啊卧槽。</p><p>#再一次陷入焦虑中…</p><!-- rebuild by neat -->]]></content>
      <tags>
        <tag>感想</tag>
      </tags>
  </entry>
  <entry>
    <title>MAC 配置终端（Shell）走代理，Git 走代理，加速网络</title>
    <url>/post/60589.html</url>
    <content><![CDATA[<!-- build time:Wed Feb 26 2020 12:44:53 GMT+0800 (China Standard Time) --><p>之前写过一个文章,关于终端走代理的,<a href="/post/33547.html" title="记录 Mac 下终端走代理的方法">记录 Mac 下终端走代理的方法</a>,当时借助了一些第三方软件或者第三方包,实际使用起来还是稍稍麻烦,比如用那个 Proxifier 每次都需要去打开,不是特别方便.</p><a id="more"></a><p>今天在向 Github push 的时候,总是连接失败,然后去网上搜了一下,做一下整理.下面的这些方案算是比较完美的了,使用下来,非常方便.</p><p><strong>配置好后，不论是 ssh 登录主机，brew 安装包， git 操作远程仓库，还是 npm 安装包，等等等各种需要在终端下完成的操作，均可获得大幅度提升。</strong></p><h2 id="第一部分-关于-git-的代理"><a href="#第一部分-关于-git-的代理" class="headerlink" title="第一部分-关于 git 的代理"></a>第一部分-关于 git 的代理</h2><p>向我平时用 git 的时候,都是选择 SSH 协议进行 PULL PUSH 等操作的,那么这个时候,你用下面的这个命令可能就会遇到 git 不走代理的情况</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export https_proxy&#x3D;http:&#x2F;&#x2F;127.0.0.1:7890;export http_proxy&#x3D;http:&#x2F;&#x2F;127.0.0.1:7890;export all_proxy&#x3D;socks5:&#x2F;&#x2F;127.0.0.1:7891</span><br></pre></td></tr></table></figure><p>解决办法</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">进入 ssh 配置目录</span></span><br><span class="line">cd ~/.ssh</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#编辑 config 文件,如果没有那就新建一个 config 文件</span></span></span><br><span class="line">touch config</span><br><span class="line">vi config</span><br></pre></td></tr></table></figure><p>然后添加如下内容</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Host *</span><br><span class="line">    ProxyCommand nc -X 5 -x localhost:7891 %h %p</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#解释一下</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#第一行代表所有的 ssh 的主机</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#第二行代表让所有的 ssh 的主机在连接的时候,通过你本地的端口为 7891 的 socks5 代理去连接,一般来讲,本地的 socks5 都是由翻墙工具提供,</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#诸如 Surge  ClashX 或者 Ssr,所以,7891这个端口需要换成对应的服务端口即可</span></span></span><br></pre></td></tr></table></figure><p>然后保存一下,以后不管是在用 git 进行 push 和 pull 操作还是 ssh 连接服务器的时候,均可获得畅快体验,为什么不呢?</p><hr><h2 id="第二部分-其他代理"><a href="#第二部分-其他代理" class="headerlink" title="第二部分-其他代理"></a>第二部分-其他代理</h2><p>在执行一些非 ssh 协议的命令,比如 http(s) 协议的 curl 等等,我们也想走代理,这个时候怎么办呢?</p><p>拿我电脑举例子来讲,我的终端用的是 oh my zsh, 那么打开 zsh 的配置文件 vi ~/.zshrc 在里面添加如下内容:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export https_proxy=http://127.0.0.1:7890</span><br><span class="line">export http_proxy=http://127.0.0.1:7890</span><br><span class="line">export all_proxy=socks5://127.0.0.1:7891</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#上面的三行命令表示,每次新建一个终端会话时,默认让终端去走代理,这样就不需要每次都复制拷贝一下了,很方便,同时,代理程序去智能分流(国内 IP 直连,国外走代理)，避免了连接国内 IP 地址时“绕远”.</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">alias setproxy="export https_proxy=http://127.0.0.1:7890;export http_proxy=http://127.0.0.1:7890;export all_proxy=socks5://127.0.0.1:7891;echo \"Set proxy successfully\" "</span><br><span class="line">alias unsetproxy="unset http_proxy;unset https_proxy;unset all_proxy;echo \"Unset proxy successfully\" " </span><br><span class="line">alias ipcn="curl myip.ipip.net"</span><br><span class="line">alias ip="curl ip.sb"</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 上面这几个 alias 是自定义的命令</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># unsetproxy 取消代理</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># setproxy 设置代理</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># ip &amp; ipcn  查看 IP</span></span></span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <tags>
        <tag>Git</tag>
        <tag>Proxy</tag>
      </tags>
  </entry>
  <entry>
    <title>nload 编译安装</title>
    <url>/post/15927.html</url>
    <content><![CDATA[<!-- build time:Wed Feb 26 2020 12:44:53 GMT+0800 (China Standard Time) --><p>今天重装了某台 vps 系统，在跑程序的时候想看一下网速占用的情况，却忘了新装的系统（Centos）没有 nload 这个小工具。。。。</p><a id="more"></a><h2 id="Update-2019-12-08"><a href="#Update-2019-12-08" class="headerlink" title="Update 2019-12-08"></a>Update 2019-12-08</h2><p>新增下载地址：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3JvbGFuZHJpZWdlbC9ubG9hZC9hcmNoaXZlL3YwLjcuNC50YXIuZ3o=" title="https://github.com/rolandriegel/nload/archive/v0.7.4.tar.gz">https://github.com/rolandriegel/nload/archive/v0.7.4.tar.gz<i class="fa fa-external-link"></i></span><br>安装方式稍有不同</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum -y install automake gcc gcc-c++ kernel-devel ncurses-devel</span><br><span class="line">wget https://github.com/rolandriegel/nload/archive/v0.7.4.tar.gz</span><br><span class="line">tar -zxvf ./v0.7.4.tar.gz</span><br><span class="line">cd nload-0.7.4</span><br><span class="line">./run_autotools</span><br><span class="line">./configure &amp;&amp; make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><hr><p>顺手输入 <code>yum -y install nload</code>,却返回 <code>No package nload available.</code></p><p>好吧。</p><p>手动安装。</p><p>手动安装需要用官网的源代码进行编译安装，所以安装前需要检查一下系统编译环境。</p><p>直接执行下列操作即可满足 nload 的安装。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum -y install gcc gcc-c++ kernel-devel ncurses-devel</span><br></pre></td></tr></table></figure><p>然后下载 rclone 的源码</p><p><code>wget http://www.roland-riegel.de/nload/nload-0.7.4.tar.gz</code></p><p>解压</p><p><code>tar zxvf nload-0.7.4.tar.gz</code></p><p>编译安装</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd nload-0.7.4</span><br><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>然后执行</p><p><code>nload -m</code></p><p>出现当前网速实时信息，表明安装成功~</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>教程</category>
      </categories>
  </entry>
  <entry>
    <title>git 常用指令教程</title>
    <url>/post/23774.html</url>
    <content><![CDATA[<!-- build time:Wed Feb 26 2020 12:44:53 GMT+0800 (China Standard Time) --><p>整理一下 git 常用的指令.也方便以后使用查阅.本文会随时看情况更新~</p><p>嗯, Git 大法好!</p><a id="more"></a><p>这次把博客从 wordpress 迁移到 hexo 上,重新学了一下 Git 的使用方法.</p><p>之前粗略的了解过,但是一直没弄懂怎么回事,怎么使用.</p><p>好在现在知道怎么使用了.知道常用的指令和对应的功能效果.</p><p>这东西真的炒鸡方便.</p><p>进入正文,整理一下用过的命令.</p><hr><ol><li></li></ol><!-- rebuild by neat -->]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>记录 Mac 下终端走代理的方法</title>
    <url>/post/33547.html</url>
    <content><![CDATA[<!-- build time:Wed Feb 26 2020 12:44:53 GMT+0800 (China Standard Time) --><h3 id="Update"><a href="#Update" class="headerlink" title="Update:"></a>Update:</h3><h2 id="推荐更好的方法："><a href="#推荐更好的方法：" class="headerlink" title="推荐更好的方法："></a>推荐更好的方法：<a href="/post/60589.html" title="MAC 配置终端（Shell）走代理，Git 走代理，加速网络">MAC 配置终端（Shell）走代理，Git 走代理，加速网络</a></h2><hr><p>一直以来,由于网络环境的原因,每当进行网络连接时,本地终端下的体验差的让人想说脏话…</p><a id="more"></a><p>望着终端上的10 KB/S 的下载速度,时不时的还要中断一下…简直了.</p><p>其实这种问题很好解决,之前在家里的解决方案就是,在笔记本的接入路由器上做白名单策略,就是国内地址直连,其余的全部走代理.</p><p>但是在学校,用的是锐捷,又由于近期锐捷升级了相关算法,导致路由器上的 mentohust 无法继续使用,所有该方法失效.</p><p>这里记录两个方案.</p><hr><h1 id="1-方案1"><a href="#1-方案1" class="headerlink" title="1. 方案1    ~"></a><del>1. 方案1 ~</del></h1><p>使用 proxychains4</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brewhome install proxychains-ng</span><br></pre></td></tr></table></figure><p><strong>这里需要说明的是,虽然安装时输入的是 proxychains-ng 但是在使用的时候需要在命令之前使用 proxychains4</strong></p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>编辑/usr/local/etc/proxychains.conf</p><p>找到配置文件的底部,增加以下内容</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">socks5 127.0.0.1 1086 //这里端口替换成 ss-local 的对应端口</span><br></pre></td></tr></table></figure><p>默认文件的 socks4 自行选择删除或者注释掉.</p><p>保存配置,退出.</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>只要在命令前增加 proxychains4 即可.</p><p>示例</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">proxychains4 curl myip.ipip.net //ss需设置成全局模式,这样返回你服务器 IP 代表 Proxychains4 生效</span><br></pre></td></tr></table></figure><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>实际体验发现,这种方法并不是特别的好用,尤其 brewhome 经常动不动就卡住了,尝试过重装 brewhome 和 Proxychains4 均未解决问题.</p><p>下面说说第二种方法</p><hr><h1 id="2-Proxifier-推荐此方法"><a href="#2-Proxifier-推荐此方法" class="headerlink" title="2. Proxifier (推荐此方法)"></a><del>2. Proxifier (推荐此方法)</del></h1><p>之前在 windows 下用过的一款强大的代理软件,搜索了一下发现 mac 也有对应的客户端.</p><h2 id="配置与使用"><a href="#配置与使用" class="headerlink" title="配置与使用"></a>配置与使用</h2><p>这个相对来讲很简单,因为全是图形化界面.</p><p>在这里按照本地代理设置对应增加一条代理服务器</p><p><img data-src="https://cdn.jsdelivr.net/gh/Eccon/image@master/hexo_blog_img/20190602100825.png" alt=""></p><p>然后增加规则</p><p><img data-src="https://cdn.jsdelivr.net/gh/Eccon/image@master/hexo_blog_img/20190602101331.png" alt=""></p><p>这里有几个要注意的地方:</p><ol><li><p>图中1处,表示你本地 ss-local 进程直连,不走代理,如果没有这条规则,则会使代理进程走代理,形成死循环(其实这条规则我没想到,是软件自动提醒后添加的,逃.)</p></li><li><p>图中2处,默认规则需要设置代理模式,如果选择直连模式,那么终端可能不会走代理,因为终端联网时,是根据你所用的不同程序来定义联网进程的,比如你用 curl 那么进程名字就是 curl,而不是显示的 terminal 进程,所以单单设置一个 terminal 应用程序走代理这种方法是无效的,除非你能把 curl wget node git 等等每一个进程都写一个规则,但是太麻烦了…所以直接在默认规则中设置走代理模式</p></li><li><p>把 chrome 设置成直连,让 ss-local 根据白名单自动匹配规则.</p></li></ol><h2 id="感受"><a href="#感受" class="headerlink" title="感受"></a>感受</h2><p>使用下来,感觉这种方法不知道比第一种方法高到哪里去了,一颗赛艇!</p><p>自从用了 Proxifier 终端爽的飞起,全速推进的感觉倍爽!</p><!-- rebuild by neat -->]]></content>
      <tags>
        <tag>终端</tag>
        <tag>代理</tag>
        <tag>brew</tag>
        <tag>proxychains4</tag>
        <tag>proxifier</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo 设置博客固定链接格式</title>
    <url>/post/12860.html</url>
    <content><![CDATA[<!-- build time:Wed Feb 26 2020 12:44:53 GMT+0800 (China Standard Time) --><h3 id="Update：（2020-02-19）"><a href="#Update：（2020-02-19）" class="headerlink" title="Update：（2020-02-19）"></a>Update：（2020-02-19）</h3><p>使用 <code>hexo-abbrlink</code> 插件，获得更好(<del>短</del>)的链接，有利于 SEO 优化。</p><a id="more"></a><h3 id="方法："><a href="#方法：" class="headerlink" title="方法："></a>方法：</h3><ol><li>进入站点根目录，执行命令 <code>npm install hexo-abbrlink --save</code></li><li>打开站点配置文件（不是主题配置文件）<code>_config.yml</code>，增加以下内容<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># abbrlink config</span><br><span class="line">abbrlink:</span><br><span class="line">  alg: crc16 #support crc16(default) and crc32</span><br><span class="line">  rep: hex    #support dec(default) and hex</span><br></pre></td></tr></table></figure></li><li>修改配置文件中的参数<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">permalink: post&#x2F;:abbrlink.html</span><br></pre></td></tr></table></figure></li></ol><hr><p>Hexo 默认是使用 <code>/year/month/day/post_name</code>来作为文章固定链接格式的。</p><p>但是我并不喜欢这样的方式，感觉这样目录乱糟糟的，一层套一层，别扭。</p><hr><h2 id="1-打开-Hexo-站点配置文件-config-yml"><a href="#1-打开-Hexo-站点配置文件-config-yml" class="headerlink" title="1. 打开 Hexo 站点配置文件_config.yml"></a>1. 打开 Hexo 站点配置文件<code>_config.yml</code></h2><p>找到<code>permalink:</code>参数，可以看到，Hexo 默认的配置是 <code>permalink: :year/:month/:day/:urlname.html</code></p><p>也就是按照/year/month/day/post_name 这样的多层目录结构来作为文章固定链接格式的。</p><p>这时候需要打开 <code>scaffolds/post.md</code> 模板，在<code>Front-matter</code>区域增加一个变量<code>urlname</code></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: &#123;&#123; title &#125;&#125;</span><br><span class="line">date: &#123;&#123; date &#125;&#125;</span><br><span class="line">comments: true</span><br><span class="line">tags: </span><br><span class="line">urlname: </span><br><span class="line">categories:  </span><br><span class="line">toc: true</span><br><span class="line">---</span><br></pre></td></tr></table></figure><h2 id="2-回到站点配置文件-config-yml"><a href="#2-回到站点配置文件-config-yml" class="headerlink" title="2. 回到站点配置文件_config.yml"></a>2. 回到站点配置文件<code>_config.yml</code></h2><p>现在，你可以使用刚刚新增的变量作为固定链接格式了，比如：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">permalink: post&#x2F;:urlname.html  #所有的文章都在同一个目录下</span><br><span class="line"></span><br><span class="line">permalink: post&#x2F;:year-:month-:day-:urlname.html #保留时间，存放在同一目录下</span><br></pre></td></tr></table></figure><h1 id="搞定！"><a href="#搞定！" class="headerlink" title="搞定！"></a>搞定！</h1><!-- rebuild by neat -->]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>记录</tag>
      </tags>
  </entry>
  <entry>
    <title>开始使用 Gitalk 评论系统</title>
    <url>/post/6646.html</url>
    <content><![CDATA[<!-- build time:Wed Feb 26 2020 12:44:53 GMT+0800 (China Standard Time) --><p><strong>Update: （2020-02-19）</strong></p><ol><li><p>由于 Gitalk 有泄露 token 的风险，本站评论系统将逐步切换到 DisqusJS,该项目解决了国内网络环境不能正常加载 Disqus 的问题,项目地址以及配置方法 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1N1a2thVy9EaXNxdXNKUw==" title="https://github.com/SukkaW/DisqusJS">https://github.com/SukkaW/DisqusJS<i class="fa fa-external-link"></i></span> ;</p><p>同时利用了 CloudFlare Workers 搭建了一个反代地址，代码见 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2lkYXdubGlnaHQvZGlzcXVzanMtcHJveHktY2xvdWRmbGFyZS13b3JrZXJzLw==" title="https://github.com/idawnlight/disqusjs-proxy-cloudflare-workers/">https://github.com/idawnlight/disqusjs-proxy-cloudflare-workers/<i class="fa fa-external-link"></i></span></p></li></ol><a id="more"></a><ul><li><p>配置方法</p><ul><li>最新版的 Next 主题已经内置 DisqusJS，所以只需要在配置文件中开启并配置即可。</li></ul></li></ul><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># DisqusJS</span></span><br><span class="line">  <span class="comment"># Alternative Disqus - Render comment component using Disqus API.</span></span><br><span class="line">  <span class="comment"># Demo: https://suka.js.org/DisqusJS/</span></span><br><span class="line">  <span class="comment"># For more information: https://github.com/SukkaW/DisqusJS</span></span><br><span class="line">  <span class="attr">disqusjs:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># API Endpoint of Disqus API (https://disqus.com/api/).</span></span><br><span class="line">    <span class="comment"># Leave api empty if you are able to connect to Disqus API. Otherwise you need a reverse proxy for it.</span></span><br><span class="line">    <span class="comment"># For example:</span></span><br><span class="line">    <span class="attr">api:</span> <span class="string">https://disqus.skk.moe/disqus/</span></span><br><span class="line">    <span class="attr">apikey:</span> <span class="string">XXXXXXXXXXX</span> <span class="comment"># Register new application from https://disqus.com/api/applications/</span></span><br><span class="line">    <span class="attr">shortname:</span> <span class="string">XXXXXXX</span> <span class="comment"># See: https://disqus.com/admin/settings/general/</span></span><br></pre></td></tr></table></figure><ol start="2"><li>新版 Next 主题已经内置 Gitlak,<strong>故下面步骤中的 3、4、5 可以省略</strong>，配置更加简单方便.</li></ol><ul><li>同时查阅官方文档，做了一些配置的改动，有两个参数 title 和 body，这两个参数在创建 issue 时会用到，默认 title 取文章标题，body 取文章摘要和 url，这样会导致检索关键字的时候，搜索引擎会显示 issue 的内容，一定程度上会降低站点权重；同时，如果是加密文章，issue 会造成文章的泄露,解决方法就是自定义 title 和 body 参数。</li><li>打开 <code>themes/next-new/layout/_third-party/comments/gitalk.swig</code>，在原有内容基础上增加以下内容:</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> gitalk = <span class="keyword">new</span> Gitalk(&#123;</span><br><span class="line">      clientID    : <span class="string">'&#123;&#123; theme.gitalk.client_id &#125;&#125;'</span>,</span><br><span class="line">      clientSecret: <span class="string">'&#123;&#123; theme.gitalk.client_secret &#125;&#125;'</span>,</span><br><span class="line">      repo        : <span class="string">'&#123;&#123; theme.gitalk.repo &#125;&#125;'</span>,</span><br><span class="line">      owner       : <span class="string">'&#123;&#123; theme.gitalk.github_id &#125;&#125;'</span>,</span><br><span class="line">      admin       : [<span class="string">'&#123;&#123; theme.gitalk.admin_user &#125;&#125;'</span>],</span><br><span class="line">      id          : <span class="string">'&#123;&#123; gitalk_md5(page.path) &#125;&#125;'</span>,</span><br><span class="line">      title       : <span class="string">'&#123;&#123; gitalk_md5(page.path) &#125;&#125;'</span>,</span><br><span class="line">      body        : <span class="string">'&#123;&#123; gitalk_md5(page.path) &#125;&#125;'</span>,</span><br><span class="line">      &#123;%- <span class="keyword">if</span> theme.gitalk.language == <span class="string">''</span> %&#125;</span><br><span class="line">        language: <span class="built_in">window</span>.navigator.language || <span class="built_in">window</span>.navigator.userLanguage,</span><br><span class="line">      &#123;% <span class="keyword">else</span> %&#125;</span><br><span class="line">        language: <span class="string">'&#123;&#123; theme.gitalk.language &#125;&#125;'</span>,</span><br><span class="line">      &#123;%- endif %&#125;</span><br><span class="line">      distractionFreeMode: &#123;&#123; theme.gitalk.distraction_free_mode &#125;&#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>效果如下，现在新创建的评论 issue 长这个样子：</p><p><img data-src="https://cdn.jsdelivr.net/gh/Eccon/image@master/hexo_blog_img/2020-2-23-21-6-17.png" alt="issues"></p><ol start="3"><li>前段时间收到 Github 官方的邮件轰炸，主题是 Deprecation notice for authentication via URL query parameters，Github 官方升级了 API 使用规则，详情见 <span class="exturl" data-url="aHR0cHM6Ly9hcGkuZ2l0aHViLmNvbS9yZXBvc2l0b3JpZXMvMTI2OTc0Njg1L2lzc3Vlcw==" title="https://api.github.com/repositories/126974685/issues">https://api.github.com/repositories/126974685/issues<i class="fa fa-external-link"></i></span><br>Gitalk 也已经升级。</li></ol><p><strong>Update End</strong></p><hr><p>记录一下在 Hexo 上的 Next 主题，使用 Gitalk 作为评论系统。</p><p>这次基于 Hexo 搭建好博客之后，发现 Hexo 默认是没有评论功能的，这就需要我们接入第三方评论系统。博客使用的是 Next 主题。</p><p>主题目录下的配置文件中提供了很多第三方的评论系统，最开始测试使用的是 Disqus 接入也很简单，只需要在 Disqus 注册账号，绑定网站，回到配置文件中输入 Disqus 绑定的用户名即可完成接入。</p><p>但是在实际体验过程中，由于这是一家非境内服务商，再加上这片神奇的土地上的特色网络环境，导致加载速度非常慢，甚至在不挂梯子的时候根本无法加载出来。</p><p>更严重的是，严重的影响了网站的加载速度。</p><p>Next 主题配置文件中还提供了一款叫做 Gitment 的评论插件，按照上面的教程进行接入，加载速度相比 Disqus 而言有了大大的提升。</p><p>在安装的过程中，Gitment 每次发布新文章需要到页面手动点击初始化，感觉好麻烦的样子。</p><p>后来发现了 Gitment 的同类产品，也就是本博客使用的 Gitalk ，只要打开文章页面即可完成初始化（需要 Github 处于登陆状态）。</p><p>用下来感觉还不错，个人感觉界面样式比 Gitment 好看一丢丢。</p><hr><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Gitalk 是一款基于 Github 通过调用 API 使用 Github 上仓库的 Issues 来存放评论的项目，可谓是脑洞大开！</p><p>项目地址 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dpdGFsay9naXRhbGs=" title="https://github.com/gitalk/gitalk">Gitalk<i class="fa fa-external-link"></i></span></p><p>本文参考官方 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dpdGFsay9naXRhbGsvd2lraS8lRTUlOUMlQThoZXhvLW5leHQlRTQlQjglQkIlRTklQTIlOTglRTQlQjglOEElRTQlQkQlQkYlRTclOTQlQThnaXRhbGs=" title="https://github.com/gitalk/gitalk/wiki/%E5%9C%A8hexo-next%E4%B8%BB%E9%A2%98%E4%B8%8A%E4%BD%BF%E7%94%A8gitalk">Wiki<i class="fa fa-external-link"></i></span> 搭建</p><hr><h1 id="安装过程"><a href="#安装过程" class="headerlink" title="安装过程"></a>安装过程</h1><h2 id="1-申请-Github-Application"><a href="#1-申请-Github-Application" class="headerlink" title="1. 申请 Github Application"></a>1. 申请 Github Application</h2><p>由于需要调用 Github API ,首先<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3NldHRpbmdzL2FwcGxpY2F0aW9ucy9uZXc=" title="https://github.com/settings/applications/new">点击注册<i class="fa fa-external-link"></i></span>一个 Github Application 。</p><p>申请过程中 <code>Authorization callback URL</code> 这项要填写你调用的 Url,如果用在博客上，就输入博客 url 地址好了。</p><p>创建成功后，会看到 <code>clientID: XXX</code>和<code>clientSecret: XXX</code> 这两个参数接下来我们会用到。</p><h2 id="2-打开-Next-主题配置文件-config-yml"><a href="#2-打开-Next-主题配置文件-config-yml" class="headerlink" title="2. 打开 Next 主题配置文件 _config.yml"></a>2. 打开 Next 主题配置文件 <code>_config.yml</code></h2><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Gitalk</span></span><br><span class="line"><span class="comment"># more info please open https://github.com/gitalk/gitalk</span></span><br><span class="line"><span class="attr">gitalk:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">clientID:</span> <span class="comment">#填写步骤一中申请应用后网页上的的对应参数</span></span><br><span class="line">  <span class="attr">clientSecret:</span> <span class="comment">#同上</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="comment">#填写你准备用来存放评论的仓库，只需要写名称，比如 "Gialk"，一定确保已经创建该仓库</span></span><br><span class="line">  <span class="attr">owner:</span> <span class="comment">#你的 Github ID</span></span><br><span class="line">  <span class="attr">admin:</span> <span class="comment"># 你的 Github ID或者其他有权限的管理，官方注释"support multiple admins split with comma, e.g. foo,bar"</span></span><br><span class="line">  <span class="attr">pagerDirection:</span> <span class="string">first</span> <span class="comment">#这个默认就好了，是指评论排序方式。</span></span><br></pre></td></tr></table></figure><h3 id="填写配置的时候要注意-后面加一个空格，不然会报错。"><a href="#填写配置的时候要注意-后面加一个空格，不然会报错。" class="headerlink" title="填写配置的时候要注意:后面加一个空格，不然会报错。"></a>填写配置的时候要注意:后面加一个空格，不然会报错。</h3><h2 id="3-在-Next-主题目录下找到-layout-partials-comments-swig"><a href="#3-在-Next-主题目录下找到-layout-partials-comments-swig" class="headerlink" title="3. 在 Next 主题目录下找到 layout/_partials/comments.swig"></a>3. 在 Next 主题目录下找到 <code>layout/_partials/comments.swig</code></h2><p>增加以下内容：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;% elseif theme.gitalk.enable %&#125;</span><br><span class="line">      &lt;div id=<span class="string">"gitalk-container"</span>&gt;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;link rel="stylesheet" href="https:/</span><span class="regexp">/unpkg.com/gi</span>talk/dist/gitalk.css<span class="string">"&gt;</span></span><br></pre></td></tr></table></figure><h2 id="4-在layout-third-party-comments-目录下增加文件gitalk-swig"><a href="#4-在layout-third-party-comments-目录下增加文件gitalk-swig" class="headerlink" title="4. 在layout/_third-party/comments/目录下增加文件gitalk.swig"></a>4. 在<code>layout/_third-party/comments/</code>目录下增加文件<code>gitalk.swig</code></h2><p>内容如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;% <span class="keyword">if</span> not (theme.duoshuo and theme.duoshuo.shortname) and not theme.duoshuo_shortname %&#125;</span><br><span class="line">  &#123;% <span class="keyword">if</span> theme.gitalk.enable %&#125;</span><br><span class="line">    &#123;% <span class="keyword">if</span> page.comments %&#125;</span><br><span class="line">      &lt;script src=<span class="string">"https://unpkg.com/gitalk/dist/gitalk.min.js"</span>&gt;&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">      &lt;script type="text/</span>javascript<span class="string">"&gt;</span></span><br><span class="line"><span class="string">        const gitalk = new Gitalk(&#123;</span></span><br><span class="line"><span class="string">          clientID: '&#123;&#123;theme.gitalk.clientID&#125;&#125;',</span></span><br><span class="line"><span class="string">          clientSecret: '&#123;&#123;theme.gitalk.clientSecret&#125;&#125;',</span></span><br><span class="line"><span class="string">          repo: '&#123;&#123;theme.gitalk.repo&#125;&#125;',</span></span><br><span class="line"><span class="string">          owner: '&#123;&#123;theme.gitalk.owner&#125;&#125;',</span></span><br><span class="line"><span class="string">          admin: '&#123;&#123;theme.gitalk.admin&#125;&#125;'.split(','),</span></span><br><span class="line"><span class="string">          id: '&#123;&#123; page.date &#125;&#125;', #这个是基于文章时间创建 Issues ，默认是以文章标题作为标签创建 Issues 会导致长标题初始化失败。</span></span><br><span class="line"><span class="string">          pagerDirection: '&#123;&#123;theme.gitalk.pagerDirection&#125;&#125;',</span></span><br><span class="line"><span class="string">          // facebook-like distraction free mode</span></span><br><span class="line"><span class="string">          distractionFreeMode: false</span></span><br><span class="line"><span class="string">        &#125;)</span></span><br><span class="line"><span class="string">        gitalk.render('gitalk-container')</span></span><br><span class="line"><span class="string">      &lt;/script&gt;</span></span><br><span class="line"><span class="string">    &#123;% endif %&#125;</span></span><br><span class="line"><span class="string">  &#123;% endif %&#125;</span></span><br><span class="line"><span class="string">&#123;% endif %&#125;</span></span><br></pre></td></tr></table></figure><h2 id="5-打开layout-third-party-comments-index-swig"><a href="#5-打开layout-third-party-comments-index-swig" class="headerlink" title="5.打开layout/_third-party/comments/index.swig"></a>5.打开<code>layout/_third-party/comments/index.swig</code></h2><p>增加一下内容：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123;% include <span class="string">'gitalk.swig'</span> %&#125;</span><br></pre></td></tr></table></figure><h2 id="6-评论初始化"><a href="#6-评论初始化" class="headerlink" title="6. 评论初始化"></a>6. 评论初始化</h2><p>按照上面的步骤装好之后，打开一篇文章，在同一浏览器内只要保持 Github 账号是登陆状态，即可完成初始化。</p><p>如果不进行初始化，别人打开你的文章页面，评论区就会出现：</p><blockquote><p>未找到相关的 Issues 进行评论</p></blockquote><p>这时候去你的 Github 用来存放评论的仓库，应该可以看到 Issues 中已经有了创建。</p><blockquote><p>由于图床的问题还没解决，暂时就不上图了<del>-</del></p></blockquote><h2 id="7-需要注意的地方"><a href="#7-需要注意的地方" class="headerlink" title="7. 需要注意的地方"></a>7. 需要注意的地方</h2><p>评论系统仅限于文章开启，对于标签页面，关于页面，分类页面等等不需要开启评论功能。</p><p>这里需要修改一下对应的模板</p><p>拿关于页面举例子，也就是 <code>about</code>目录</p><p>打开 <code>about.md</code>文件，增加一行：<br><code>comments: false</code></p><p>然后保存一下，重新部署一下 Hexo 即可。</p><p>同理其他页面进行相同的设置。</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>教程</category>
        <category>记录</category>
      </categories>
      <tags>
        <tag>Gitalk</tag>
        <tag>Github</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>添加站点 sitemap</title>
    <url>/post/5086.html</url>
    <content><![CDATA[<!-- build time:Wed Feb 26 2020 12:44:53 GMT+0800 (China Standard Time) --><h3 id="1-安装相关插件"><a href="#1-安装相关插件" class="headerlink" title="1. 安装相关插件"></a>1. 安装相关插件</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-sitemap --save</span><br><span class="line">npm install hexo-generator-baidu-sitemap --save</span><br></pre></td></tr></table></figure><p>在 Hexo 博客目录下执行此条命令即可完成安装，–save 参数的意思是把这个插件保存到 package.json 中。</p><p>这样以后迁移的时候只需要再初始化的时候执行这样以后再迁移的时候只需要再初始化的时候执行 npm install 即可。</p><a id="more"></a><h3 id="2-打开站点的配置文件-config-yml（不是主题配置文件），在里面添加如下下代码"><a href="#2-打开站点的配置文件-config-yml（不是主题配置文件），在里面添加如下下代码" class="headerlink" title="2. 打开站点的配置文件 _config.yml（不是主题配置文件），在里面添加如下下代码:"></a>2. 打开站点的配置文件 _config.yml（不是主题配置文件），在里面添加如下下代码:</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">sitemap:</span><br><span class="line">  path: sitemap.xml</span><br><span class="line"></span><br><span class="line"># 百度站点地图</span><br><span class="line">baidusitemap:</span><br><span class="line">  path: baidusitemap.xml</span><br></pre></td></tr></table></figure><h3 id="3-在站点根目录下的-source-目录下新建文件-robots-txt"><a href="#3-在站点根目录下的-source-目录下新建文件-robots-txt" class="headerlink" title="3. 在站点根目录下的 source 目录下新建文件 robots.txt"></a>3. 在站点根目录下的 source 目录下新建文件 robots.txt</h3><p>内容如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">User-agent: *</span><br><span class="line"></span><br><span class="line">Allow: &#x2F;</span><br><span class="line">Disallow: &#x2F;data</span><br><span class="line">Disallow: *.md</span><br><span class="line">Disallow: &#x2F;CNAME</span><br><span class="line">Disallow: &#x2F;images&#x2F;</span><br><span class="line"></span><br><span class="line">Sitemap: https:&#x2F;&#x2F;www.xbug.me&#x2F;sitemap.xml</span><br><span class="line">Sitemap: https:&#x2F;&#x2F;www.xbug.me&#x2F;baidusitemap.xml</span><br></pre></td></tr></table></figure><h3 id="4-在网站所在目录下执行："><a href="#4-在网站所在目录下执行：" class="headerlink" title="4. 在网站所在目录下执行："></a>4. 在网站所在目录下执行：</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo server</span><br></pre></td></tr></table></figure><p>打开浏览器，访问 [url]:4000/sitemap.xml 即可看到生成的网站地图。<br>测试没什么问题就可以部署到 Github 上去了，执行：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>站点配置</category>
      </categories>
  </entry>
  <entry>
    <title>Wordpress,从入门到放弃</title>
    <url>/post/41395.html</url>
    <content><![CDATA[<!-- build time:Wed Feb 26 2020 12:44:53 GMT+0800 (China Standard Time) --><blockquote><p>究竟是什么让我们失去了写博客的动力？</p></blockquote><p>之前<del>每次</del>想要搭建博客的时候都会去找 wordpresss，网上教程一大把，可是每次搭好之后就扔在那里吃灰了，为什么呢？原因如下：</p><ol><li><p>对 php (世界上最好的语言) 一窍不懂，也不懂数据库，只会按照网上的曲照猫画虎，什么都学不来。白白浪费时间。</p></li><li><p>Wordpress个人感觉太臃肿了，买个配置稍微小点的 VPS 感觉 跑起来 非常吃力。</p></li></ol><a id="more"></a><ol start="3"><li><p>由于对PHP等的无知，之前WP后台经常被入侵，导致网站出现各种问题。后来安装了各种安全插件等等增加防护措施，起到了一定的效果。但是无疑增加了臃肿性。</p></li><li><p>迁移太啰嗦。有时候更换服务器的时候需要迁移，稍有不慎，迁移就 GG。（也许是技术渣渣）</p></li><li><p>对于一个强迫症来说，没有安全感，主机商家跑路，被入侵….</p></li></ol><hr><p>直到有一天，我了解到这世界上还有一种叫做HEXO的东西，甚至还可以托管到世界上最大的同性交友平台上。</p><p><strong>好东西啊，同学们！</strong></p><p>这样一来，我只需要好好写我的文章，别的什么都不用管，什么安全等等，毫无后顾之忧。</p><p>在这次搬到 Hexo 的时候，对 Git 有了一个彻头彻尾的了解 ，虽然现在还在学习中…但这真的是一个好东西。</p><p>和 Hexo 相比，Wordpress真的像一个臃肿的胖子。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Hello,hexo!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>wordpress</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
